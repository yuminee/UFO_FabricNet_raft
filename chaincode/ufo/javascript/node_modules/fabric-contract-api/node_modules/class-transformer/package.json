{
  "_args": [
    [
      "class-transformer@https://registry.npmjs.org/class-transformer/-/class-transformer-0.2.3.tgz",
      "/home/yumin/UFO_FabricNet_raft/chaincode/ufo/javascript/node_modules/fabric-contract-api"
    ]
  ],
  "_from": "class-transformer@https://registry.npmjs.org/class-transformer/-/class-transformer-0.2.3.tgz",
  "_id": "class-transformer@0.2.3",
  "_inCache": true,
  "_location": "/fabric-contract-api/class-transformer",
  "_phantomChildren": {},
  "_requested": {
    "name": "class-transformer",
    "raw": "class-transformer@https://registry.npmjs.org/class-transformer/-/class-transformer-0.2.3.tgz",
    "rawSpec": "https://registry.npmjs.org/class-transformer/-/class-transformer-0.2.3.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/class-transformer/-/class-transformer-0.2.3.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/fabric-contract-api"
  ],
  "_resolved": "https://registry.npmjs.org/class-transformer/-/class-transformer-0.2.3.tgz",
  "_shasum": "598c92ca71dcca73f91ccb875d74a3847ccfa32d",
  "_shrinkwrap": null,
  "_spec": "class-transformer@https://registry.npmjs.org/class-transformer/-/class-transformer-0.2.3.tgz",
  "_where": "/home/yumin/UFO_FabricNet_raft/chaincode/ufo/javascript/node_modules/fabric-contract-api",
  "author": {
    "email": "pleerock.me@gmail.com",
    "name": "Umed Khudoiberdiev"
  },
  "bugs": {
    "url": "https://github.com/pleerock/class-transformer/issues"
  },
  "dependencies": {},
  "description": "Proper decorator-based transformation / serialization / deserialization of plain javascript objects to class constructors",
  "devDependencies": {
    "@types/chai": "^3.4.34",
    "@types/es6-shim": "^0.31.32",
    "@types/mocha": "^2.2.33",
    "@types/moment": "^2.13.0",
    "@types/node": "0.0.2",
    "@types/sinon": "^2.2.2",
    "chai": "^4.2.0",
    "chai-as-promised": "^7.1.1",
    "del": "^2.2.1",
    "es6-shim": "^0.35.1",
    "gulp": "^3.9.1",
    "gulp-file": "^0.3.0",
    "gulp-istanbul": "^1.0.0",
    "gulp-mocha": "^3.0.1",
    "gulp-rename": "^1.2.2",
    "gulp-replace": "^0.5.4",
    "gulp-shell": "^0.5.1",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-tslint": "^8.1.3",
    "gulp-typescript": "^3.1.3",
    "gulp-uglify": "^2.0.0",
    "gulpclass": "^0.1.1",
    "mocha": "^3.2.0",
    "moment": "2.14.1",
    "reflect-metadata": "^0.1.3",
    "remap-istanbul": "^0.7.0",
    "sinon": "^1.17.4",
    "sinon-chai": "^2.8.0",
    "tslint": "^4.0.2",
    "tslint-stylish": "^2.1.0-beta",
    "typescript": "^2.0.10"
  },
  "homepage": "https://github.com/pleerock/class-transformer#readme",
  "license": "MIT",
  "name": "class-transformer",
  "optionalDependencies": {},
  "private": false,
  "readme": "# class-transformer\r\n\r\n[![Build Status](https://travis-ci.org/typestack/class-transformer.svg?branch=master)](https://travis-ci.org/typestack/class-transformer)\r\n[![codecov](https://codecov.io/gh/typestack/class-transformer/branch/master/graph/badge.svg)](https://codecov.io/gh/typestack/class-transformer)\r\n[![npm version](https://badge.fury.io/js/class-transformer.svg)](https://badge.fury.io/js/class-transformer)\r\n[![Dependency Status](https://david-dm.org/typestack/class-transformer.svg)](https://david-dm.org/typestack/class-transformer)\r\n[![Join the chat at https://gitter.im/typestack/class-transformer](https://badges.gitter.im/typestack/class-transformer.svg)](https://gitter.im/typestack/class-transformer?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nIts ES6 and Typescript era. Nowadays you are working with classes and constructor objects more then ever.\r\nClass-transformer allows you to transform plain object to some instance of class and versa.\r\nAlso it allows to serialize / deserialize object based on criteria.\r\nThis tool is super useful on both frontend and backend.\r\n\r\nExample how to use with angular 2 in [plunker](http://plnkr.co/edit/Mja1ZYAjVySWASMHVB9R).\r\nSource code is available [here](https://github.com/pleerock/class-transformer-demo).\r\n\r\n## What is class-transformer\r\n\r\nIn JavaScript there are two types of objects:\r\n\r\n* plain (literal) objects\r\n* class (constructor) objects\r\n\r\nPlain objects are objects that are instances of `Object` class.\r\nSometimes they are called **literal** objects, when created via `{}` notation.\r\nClass objects are instances of classes with own defined constructor, properties and methods.\r\nUsually you define them via `class` notation.\r\n\r\nSo, what is the problem?\r\n\r\nSometimes you want to transform plain javascript object to the ES6 **classes** you have.\r\nFor example, if you are loading a json from your backend, some api or from a json file,\r\nand after you `JSON.parse` it you have a plain javascript object, not instance of class you have.\r\n\r\nFor example you have a list of users in your `users.json` that you are loading:\r\n\r\n```json\r\n[{\r\n  \"id\": 1,\r\n  \"firstName\": \"Johny\",\r\n  \"lastName\": \"Cage\",\r\n  \"age\": 27\r\n},\r\n{\r\n  \"id\": 2,\r\n  \"firstName\": \"Ismoil\",\r\n  \"lastName\": \"Somoni\",\r\n  \"age\": 50\r\n},\r\n{\r\n  \"id\": 3,\r\n  \"firstName\": \"Luke\",\r\n  \"lastName\": \"Dacascos\",\r\n  \"age\": 12\r\n}]\r\n```\r\nAnd you have a `User` class:\r\n\r\n```javascript\r\nexport class User {\r\n    id: number;\r\n    firstName: string;\r\n    lastName: string;\r\n    age: number;\r\n\r\n    getName() {\r\n        return this.firstName + \" \" + this.lastName;\r\n    }\r\n\r\n    isAdult() {\r\n        return this.age > 36 && this.age < 60;\r\n    }\r\n}\r\n```\r\n\r\nYou are assuming that you are downloading users of type `User` from `users.json` file and may want to write\r\nfollowing code:\r\n\r\n```javascript\r\nfetch(\"users.json\").then((users: User[]) => {\r\n    // you can use users here, and type hinting also will be available to you,\r\n    //  but users are not actually instances of User class\r\n    // this means that you can't use methods of User class\r\n});\r\n```\r\n\r\nIn this code you can use `users[0].id`, you can also use `users[0].firstName` and `users[0].lastName`.\r\nHowever you cannot use `users[0].getName()` or `users[0].isAdult()` because \"users\" actually is\r\narray of plain javascript objects, not instances of User object.\r\nYou actually lied to compiler when you said that its `users: User[]`.\r\n\r\nSo what to do? How to make a `users` array of instances of `User` objects instead of plain javascript objects?\r\nSolution is to create new instances of User object and manually copy all properties to new objects.\r\nBut things may go wrong very fast once you have a more complex object hierarchy.\r\n\r\nAlternatives? Yes, you can use class-transformer. Purpose of this library is to help you to map you plain javascript\r\nobjects to the instances of classes you have.\r\n\r\nThis library also great for models exposed in your APIs,\r\nbecause it provides a great tooling to control what your models are exposing in your API.\r\nHere is example how it will look like:\r\n\r\n```javascript\r\nfetch(\"users.json\").then((users: Object[]) => {\r\n    const realUsers = plainToClass(User, users);\r\n    // now each user in realUsers is instance of User class\r\n});\r\n```\r\n\r\nNow you can use `users[0].getName()` and `users[0].isAdult()` methods.\r\n\r\n## Installation\r\n\r\n### Node.js\r\n\r\n1. Install module:\r\n\r\n    `npm install class-transformer --save`\r\n\r\n2. `reflect-metadata` shim is required, install it too:\r\n\r\n    `npm install reflect-metadata --save`\r\n\r\n    and make sure to import it in a global place, like app.ts:\r\n\r\n    ```javascript\r\n    import \"reflect-metadata\";\r\n    ```\r\n\r\n3. ES6 features are used, if you are using old version of node.js you may need to install es6-shim:\r\n\r\n   `npm install es6-shim --save`\r\n\r\n   and import it in a global place like app.ts:\r\n\r\n    ```javascript\r\n    import \"es6-shim\";\r\n    ```\r\n\r\n### Browser\r\n\r\n1. Install module:\r\n\r\n    `npm install class-transformer --save`\r\n\r\n2. `reflect-metadata` shim is required, install it too:\r\n\r\n    `npm install reflect-metadata --save`\r\n\r\n    add `<script>` to reflect-metadata in the head of your `index.html`:\r\n\r\n    ```html\r\n    <html>\r\n       <head>\r\n           <!-- ... -->\r\n           <script src=\"node_modules/reflect-metadata/Reflect.js\"></script>\r\n       </head>\r\n       <!-- ... -->\r\n    </html>\r\n    ```\r\n\r\n    If you are using angular 2 you should already have this shim installed.\r\n\r\n3. If you are using system.js you may want to add this into `map` and `package` config:\r\n\r\n    ```json\r\n    {\r\n        \"map\": {\r\n            \"class-transformer\": \"node_modules/class-transformer\"\r\n        },\r\n        \"packages\": {\r\n            \"class-transformer\": { \"main\": \"index.js\", \"defaultExtension\": \"js\" }\r\n        }\r\n    }\r\n    ```\r\n\r\n## Methods\r\n\r\n#### plainToClass\r\n\r\nThis method transforms a plain javascript object to instance of specific class.\r\n\r\n```javascript\r\nimport {plainToClass} from \"class-transformer\";\r\n\r\nlet users = plainToClass(User, userJson); // to convert user plain object a single user. also supports arrays\r\n```\r\n\r\n#### plainToClassFromExist\r\n\r\nThis method transforms a plain object into a instance using a already filled Object which is a instance from the target class.\r\n\r\n```javascript\r\nconst defaultUser = new User();\r\ndefaultUser.role = 'user';\r\n\r\nlet mixedUser = plainToClassFromExist(defaultUser, user); // mixed user should have the value role = user when no value is set otherwise.\r\n```\r\n\r\n#### classToPlain\r\n\r\nThis method transforms your class object back to plain javascript object, that can be `JSON.stringify` later.\r\n\r\n```javascript\r\nimport {classToPlain} from \"class-transformer\";\r\nlet photo = classToPlain(photo);\r\n```\r\n\r\n#### classToClass\r\n\r\nThis method transforms your class object into new instance of the class object.\r\nThis maybe treated as deep clone of your objects.\r\n\r\n```javascript\r\nimport {classToClass} from \"class-transformer\";\r\nlet photo = classToClass(photo);\r\n```\r\n\r\nYou can also use a `ignoreDecorators` option in transformation options to ignore all decorators you classes is using.\r\n\r\n#### serialize\r\n\r\nYou can serialize your model right to the json using `serialize` method:\r\n\r\n```javascript\r\nimport {serialize} from \"class-transformer\";\r\nlet photo = serialize(photo);\r\n```\r\n\r\n`serialize` works with both arrays and non-arrays.\r\n\r\n#### deserialize and deserializeArray\r\n\r\nYou can deserialize your model to from a json using `deserialize` method:\r\n\r\n```javascript\r\nimport {deserialize} from \"class-transformer\";\r\nlet photo = deserialize(Photo, photo);\r\n```\r\n\r\nTo make deserialization to work with arrays use `deserializeArray` method:\r\n\r\n```javascript\r\nimport {deserializeArray} from \"class-transformer\";\r\nlet photos = deserializeArray(Photo, photos);\r\n```\r\n\r\n## Enforcing type-safe instance\r\n\r\nThe default behaviour of the `plainToClass` method is to set *all* properties from the plain object,\r\neven those which are not specified in the class.\r\n\r\n```javascript\r\nimport {plainToClass} from \"class-transformer\";\r\n\r\nclass User {\r\n  id: number\r\n  firstName: string\r\n  lastName: string\r\n}\r\n\r\nconst fromPlainUser = {\r\n  unkownProp: 'hello there',\r\n  firstName: 'Umed',\r\n  lastName: 'Khudoiberdiev',\r\n}\r\n\r\nconsole.log(plainToClass(User, fromPlainUser))\r\n\r\n// User {\r\n//   unkownProp: 'hello there',\r\n//   firstName: 'Umed',\r\n//   lastName: 'Khudoiberdiev',\r\n// }\r\n```\r\n\r\nIf this behaviour does not suit your needs, you can use the `excludeExtraneousValues` option\r\nin the `plainToClass` method while *exposing all your class properties* as a requirement.\r\n\r\n```javascript\r\nimport {Expose, plainToClass} from \"class-transformer\";\r\n\r\nclass User {\r\n    @Expose() id: number;\r\n    @Expose() firstName: string;\r\n    @Expose() lastName: string;\r\n}\r\n\r\nconst fromPlainUser = {\r\n  unkownProp: 'hello there',\r\n  firstName: 'Umed',\r\n  lastName: 'Khudoiberdiev',\r\n}\r\n\r\nconsole.log(plainToClass(User, fromPlainUser, { excludeExtraneousValues: true }))\r\n\r\n// User {\r\n//   id: undefined,\r\n//   firstName: 'Umed',\r\n//   lastName: 'Khudoiberdiev'\r\n// }\r\n```\r\n\r\n## Working with nested objects\r\n\r\nWhen you are trying to transform objects that have nested objects,\r\nits required to known what type of object you are trying to transform.\r\nSince Typescript does not have good reflection abilities yet,\r\nwe should implicitly specify what type of object each property contain.\r\nThis is done using `@Type` decorator.\r\n\r\nLets say we have an album with photos.\r\nAnd we are trying to convert album plain object to class object:\r\n\r\n```javascript\r\nimport {Type, plainToClass} from \"class-transformer\";\r\n\r\nexport class Album {\r\n\r\n    id: number;\r\n\r\n    name: string;\r\n\r\n    @Type(() => Photo)\r\n    photos: Photo[];\r\n}\r\n\r\nexport class Photo {\r\n    id: number;\r\n    filename: string;\r\n}\r\n\r\nlet album = plainToClass(Album, albumJson);\r\n// now album is Album object with Photo objects inside\r\n```\r\n\r\n### Providing more than one type option\r\n\r\nIn case the nested object can be of different types, you can provide an additional options object,\r\nthat specifies a discriminator. The discriminator option must define a `property` that holds the sub\r\ntype name for the object and the possible `subTypes`, the nested object can converted to. A sub type\r\nhas a `value`, that holds the constructor of the Type and the `name`, that can match with the `property`\r\nof the discriminator.\r\n\r\nLets say we have an album that has a top photo. But this photo can be of certain different types.\r\nAnd we are trying to convert album plain object to class object. The plain object input has to define\r\nthe additional property `__type`. This property is removed during transformation by default:\r\n\r\n**JSON input**:\r\n```json\r\n{\r\n    \"id\": 1,\r\n    \"name\": \"foo\",\r\n    \"topPhoto\": {\r\n        \"id\": 9,\r\n        \"filename\": \"cool_wale.jpg\",\r\n        \"depth\": 1245,\r\n        \"__type\": \"underwater\"\r\n    }\r\n}\r\n```\r\n\r\n```javascript\r\nimport {Type, plainToClass} from \"class-transformer\";\r\n\r\nexport abstract class Photo {\r\n    id: number;\r\n    filename: string;\r\n}\r\n\r\nexport class Landscape extends Photo {\r\n    panorama: boolean;\r\n}\r\n\r\nexport class Portrait extends Photo {\r\n    person: Person;\r\n}\r\n\r\nexport class UnderWater extends Photo {\r\n    depth: number;\r\n}\r\n\r\nexport class Album {\r\n\r\n    id: number;\r\n    name: string;\r\n\r\n    @Type(() => Photo, {\r\n        discriminator: {\r\n            property: \"__type\",\r\n            subTypes: [\r\n                { value: Landscape, name: \"landscape\" },\r\n                { value: Portrait, name: \"portrait\" },\r\n                { value: UnderWater, name: \"underwater\" }\r\n            ]\r\n        }\r\n    })\r\n    topPhoto: Landscape | Portrait | UnderWater;\r\n\r\n}\r\n\r\nlet album = plainToClass(Album, albumJson);\r\n// now album is Album object with a UnderWater object without `__type` property.\r\n```\r\n\r\nHint: The same applies for arrays with different sub types. Moreover you can specify `keepDiscriminatorProperty: true`\r\nin the options to keep the discriminator property also inside your resulting class.\r\n\r\n## Exposing getters and method return values\r\n\r\nYou can expose what your getter or method return by setting a `@Expose()` decorator to those getters or methods:\r\n\r\n```javascript\r\nimport {Expose} from \"class-transformer\";\r\n\r\nexport class User {\r\n\r\n    id: number;\r\n    firstName: string;\r\n    lastName: string;\r\n    password: string;\r\n\r\n    @Expose()\r\n    get name() {\r\n        return this.firstName + \" \" + this.lastName;\r\n    }\r\n\r\n    @Expose()\r\n    getFullName() {\r\n        return this.firstName + \" \" + this.lastName;\r\n    }\r\n}\r\n```\r\n\r\n## Exposing properties with different names\r\n\r\nIf you want to expose some of properties with a different name,\r\nyou can do it by specifying a `name` option to `@Expose` decorator:\r\n\r\n```javascript\r\nimport {Expose} from \"class-transformer\";\r\n\r\nexport class User {\r\n\r\n    @Expose({ name: \"uid\" })\r\n    id: number;\r\n\r\n    firstName: string;\r\n\r\n    lastName: string;\r\n\r\n    @Expose({ name: \"secretKey\" })\r\n    password: string;\r\n\r\n    @Expose({ name: \"fullName\" })\r\n    getFullName() {\r\n        return this.firstName + \" \" + this.lastName;\r\n    }\r\n}\r\n```\r\n\r\n## Skipping specific properties\r\n\r\nSometimes you want to skip some properties during transformation.\r\nThis can be done using `@Exclude` decorator:\r\n\r\n```javascript\r\nimport {Exclude} from \"class-transformer\";\r\n\r\nexport class User {\r\n\r\n    id: number;\r\n\r\n    email: string;\r\n\r\n    @Exclude()\r\n    password: string;\r\n}\r\n```\r\n\r\nNow when you transform a User, `password` property will be skipped and not be included in the transformed result.\r\n\r\n## Skipping depend of operation\r\n\r\nYou can control on what operation you will exclude a property. Use `toClassOnly` or `toPlainOnly` options:\r\n\r\n```javascript\r\nimport {Exclude} from \"class-transformer\";\r\n\r\nexport class User {\r\n\r\n    id: number;\r\n\r\n    email: string;\r\n\r\n    @Exclude({ toPlainOnly: true })\r\n    password: string;\r\n}\r\n```\r\n\r\nNow `password` property will be excluded only during `classToPlain` operation. Oppositely, use `toClassOnly` option.\r\n\r\n## Skipping all properties of the class\r\n\r\nYou can skip all properties of the class, and expose only those are needed explicitly:\r\n\r\n```javascript\r\nimport {Exclude, Expose} from \"class-transformer\";\r\n\r\n@Exclude()\r\nexport class User {\r\n\r\n    @Expose()\r\n    id: number;\r\n\r\n    @Expose()\r\n    email: string;\r\n\r\n    password: string;\r\n}\r\n```\r\n\r\nNow `id` and `email` will be exposed, and password will be excluded during transformation.\r\nAlternatively, you can set exclusion strategy during transformation:\r\n\r\n```javascript\r\nimport {classToPlain} from \"class-transformer\";\r\nlet photo = classToPlain(photo, { strategy: \"excludeAll\" });\r\n```\r\n\r\nIn this case you don't need to `@Exclude()` a whole class.\r\n\r\n## Skipping private properties, or some prefixed properties\r\n\r\nIf you name your private properties with a prefix, lets say with `_`,\r\nthen you can exclude such properties from transformation too:\r\n\r\n```javascript\r\nimport {classToPlain} from \"class-transformer\";\r\nlet photo = classToPlain(photo, { excludePrefixes: [\"_\"] });\r\n```\r\n\r\nThis will skip all properties that start with `_` prefix.\r\nYou can pass any number of prefixes and all properties that begin with these prefixes will be ignored.\r\nFor example:\r\n\r\n```javascript\r\nimport {Expose} from \"class-transformer\";\r\n\r\nexport class User {\r\n\r\n    id: number;\r\n    private _firstName: string;\r\n    private _lastName: string;\r\n    _password: string;\r\n\r\n    setName(firstName: string, lastName: string) {\r\n        this._firstName = firstName;\r\n        this._lastName = lastName;\r\n    }\r\n\r\n    @Expose()\r\n    get name() {\r\n        return this.firstName + \" \" + this.lastName;\r\n    }\r\n\r\n}\r\n\r\nconst user = new User();\r\nuser.id = 1;\r\nuser.setName(\"Johny\", \"Cage\");\r\nuser._password = 123;\r\n\r\nconst plainUser = classToPlain(user, { excludePrefixes: [\"_\"] });\r\n// here plainUser will be equal to\r\n// { id: 1, name: \"Johny Cage\" }\r\n```\r\n\r\n## Using groups to control excluded properties\r\n\r\nYou can use groups to control what data will be exposed and what will not be:\r\n\r\n```javascript\r\nimport {Exclude, Expose} from \"class-transformer\";\r\n\r\n@Exclude()\r\nexport class User {\r\n\r\n    id: number;\r\n\r\n    name: string;\r\n\r\n    @Expose({ groups: [\"user\", \"admin\"] }) // this means that this data will be exposed only to users and admins\r\n    email: string;\r\n\r\n    @Expose({ groups: [\"user\"] }) // this means that this data will be exposed only to users\r\n    password: string;\r\n}\r\n```\r\n\r\n```javascript\r\nimport {classToPlain} from \"class-transformer\";\r\nlet user1 = classToPlain(user, { groups: [\"user\"] }); // will contain id, name, email and password\r\nlet user2 = classToPlain(user, { groups: [\"admin\"] }); // will contain id, name and email\r\n```\r\n\r\n## Using versioning to control exposed and excluded properties\r\n\r\nIf you are building an API that has different versions, class-transformer has extremely useful tools for that.\r\nYou can control which properties of your model should be exposed or excluded in what version. Example:\r\n\r\n```javascript\r\nimport {Exclude, Expose} from \"class-transformer\";\r\n\r\n@Exclude()\r\nexport class User {\r\n\r\n    id: number;\r\n\r\n    name: string;\r\n\r\n    @Expose({ since: 0.7, until: 1 }) // this means that this property will be exposed for version starting from 0.7 until 1\r\n    email: string;\r\n\r\n    @Expose({ since: 2.1 }) // this means that this property will be exposed for version starting from 2.1\r\n    password: string;\r\n}\r\n```\r\n\r\n```javascript\r\nimport {classToPlain} from \"class-transformer\";\r\nlet user1 = classToPlain(user, { version: 0.5 }); // will contain id and name\r\nlet user2 = classToPlain(user, { version: 0.7 }); // will contain id, name and email\r\nlet user3 = classToPlain(user, { version: 1 }); // will contain id and name\r\nlet user4 = classToPlain(user, { version: 2 }); // will contain id and name\r\nlet user5 = classToPlain(user, { version: 2.1 }); // will contain id, name nad password\r\n```\r\n\r\n## Ð¡onverting date strings into Date objects\r\n\r\nSometimes you have a Date in your plain javascript object received in a string format.\r\nAnd you want to create a real javascript Date object from it.\r\nYou can do it simply by passing a Date object to the `@Type` decorator:\r\n\r\n```javascript\r\nimport {Type} from \"class-transformer\";\r\n\r\nexport class User {\r\n\r\n    id: number;\r\n\r\n    email: string;\r\n\r\n    password: string;\r\n\r\n    @Type(() => Date)\r\n    registrationDate: Date;\r\n}\r\n```\r\n\r\nNote, that dates will be converted to strings when you'll try to convert class object to plain object.\r\n\r\nSame technique can be used with `Number`, `String`, `Boolean`\r\nprimitive types when you want to convert your values into these types.\r\n\r\n## Working with arrays\r\n\r\nWhen you are using arrays you must provide a type of the object that array contains.\r\nThis type, you specify in a `@Type()` decorator:\r\n\r\n```javascript\r\nimport {Type} from \"class-transformer\";\r\n\r\nexport class Photo {\r\n\r\n    id: number;\r\n\r\n    name: string;\r\n\r\n    @Type(() => Album)\r\n    albums: Album[];\r\n}\r\n```\r\n\r\nYou can also use custom array types:\r\n\r\n```javascript\r\nimport {Type} from \"class-transformer\";\r\n\r\nexport class AlbumCollection extends Array<Album> {\r\n    // custom array functions ...\r\n}\r\n\r\nexport class Photo {\r\n\r\n    id: number;\r\n\r\n    name: string;\r\n\r\n    @Type(() => Album)\r\n    albums: AlbumCollection;\r\n}\r\n```\r\n\r\nLibrary will handle proper transformation automatically.\r\n\r\nES6 collections `Set` and `Map` also require the `@Type` decorator:\r\n\r\n```javascript\r\nexport class Skill {\r\n    name: string;\r\n}\r\n\r\nexport class Weapon {\r\n    name: string;\r\n    range: number;\r\n}\r\n\r\nexport class Player {\r\n    name: string;\r\n\r\n    @Type(() => Skill)\r\n    skills: Set<Skill>;\r\n\r\n    @Type(() => Weapon)\r\n    weapons: Map<string, Weapon>;\r\n}\r\n```\r\n\r\n## Additional data transformation\r\n\r\n### Basic usage\r\n\r\nYou can perform additional data transformation using `@Transform` decorator.\r\nFor example, you want to make your `Date` object to be a `moment` object when you are\r\ntransforming object from plain to class:\r\n\r\n```javascript\r\nimport {Transform} from \"class-transformer\";\r\nimport * as moment from \"moment\";\r\nimport {Moment} from \"moment\";\r\n\r\nexport class Photo {\r\n\r\n    id: number;\r\n\r\n    @Type(() => Date)\r\n    @Transform(value => moment(value), { toClassOnly: true })\r\n    date: Moment;\r\n}\r\n```\r\n\r\nNow when you call `plainToClass` and send a plain representation of the Photo object,\r\nit will convert a date value in your photo object to moment date.\r\n`@Transform` decorator also supports groups and versioning.\r\n\r\n### Advanced usage\r\n\r\nThe `@Transform` decorator is given more arguments to let you configure how you want the transformation to be done.\r\n\r\n```\r\n@Transform((value, obj, type) => value)\r\n```\r\n\r\n| Argument          | Description\r\n|--------------------|---------------------------------------------------------------------------------|\r\n| `value` | The property value before the transformation.\r\n| `obj` | The transformation source object.\r\n| `type` | The transformation type.\r\n\r\n## Other decorators\r\n| Signature          | Example                                  | Description\r\n|--------------------|------------------------------------------|---------------------------------------------|\r\n| `@TransformClassToPlain` | `@TransformClassToPlain({ groups: [\"user\"] })` | Transform the method return with classToPlain and expose the properties on the class.\r\n| `@TransformClassToClass` | `@TransformClassToClass({ groups: [\"user\"] })` | Transform the method return with classToClass and expose the properties on the class.\r\n| `@TransformPlainToClass` | `@TransformPlainToClass(User, { groups: [\"user\"] })` | Transform the method return with plainToClass and expose the properties on the class.\r\n\r\nThe above decorators accept one optional argument:\r\nClassTransformOptions - The transform options like groups, version, name\r\n\r\nAn example:\r\n\r\n```javascript\r\n@Exclude()\r\nclass User {\r\n\r\n    id: number;\r\n\r\n    @Expose()\r\n    firstName: string;\r\n\r\n    @Expose()\r\n    lastName: string;\r\n\r\n    @Expose({ groups: ['user.email'] })\r\n    email: string;\r\n\r\n    password: string;\r\n}\r\n\r\nclass UserController {\r\n\r\n    @TransformClassToPlain({ groups: ['user.email'] })\r\n    getUser() {\r\n        const user = new User();\r\n        user.firstName = \"Snir\";\r\n        user.lastName = \"Segal\";\r\n        user.password = \"imnosuperman\";\r\n\r\n        return user;\r\n    }\r\n}\r\n\r\nconst controller = new UserController();\r\nconst user = controller.getUser();\r\n```\r\n\r\nthe `user` variable will contain only firstName,lastName, email properties becuase they are\r\nthe exposed variables. email property is also exposed becuase we metioned the group \"user.email\".\r\n\r\n## Working with generics\r\n\r\nGenerics are not supported because TypeScript does not have good reflection abilities yet.\r\nOnce TypeScript team provide us better runtime type reflection tools, generics will be implemented.\r\nThere are some tweaks however you can use, that maybe can solve your problem.\r\n[Checkout this example.](https://github.com/pleerock/class-transformer/tree/master/sample/sample4-generics)\r\n\r\n## Implicit type conversion\r\n\r\n> **NOTE** If you use class-validator together with class-transformer you propably DON'T want to enable this function.\r\n\r\nEnables automatic conversion between built-in types based on type information provided by Typescript. Disabled by default.\r\n\r\n```ts\r\nimport { IsString } from 'class-validator'\r\n\r\nclass MyPayload {\r\n\r\n  @IsString()\r\n  prop: string\r\n}\r\n\r\n\r\nconst result1 = plainToClass(MyPayload, { prop: 1234 }, { enableImplicitConversion: true });\r\nconst result2 = plainToClass(MyPayload, { prop: 1234 }, { enableImplicitConversion: false });\r\n\r\n/**\r\n *  result1 will be `{ prop: \"1234\" }` - notice how the prop value has been converted to string.\r\n *  result2 will be `{ prop: 1234 }` - default behaviour\r\n */\r\n```\r\n\r\n## How does it handle circular references?\r\n\r\nCircular references are ignored.\r\nFor example, if you are transforming class `User` that contains property `photos` with type of `Photo`,\r\n and `Photo` contains link `user` to its parent `User`, then `user` will be ignored during transformation.\r\nCircular references are not ignored only during `classToClass` operation.\r\n\r\n## Example with Angular2\r\n\r\nLets say you want to download users and want them automatically to be mapped to the instances of `User` class.\r\n\r\n```javascript\r\nimport {plainToClass} from \"class-transformer\";\r\n\r\nthis.http\r\n    .get(\"users.json\")\r\n    .map(res => res.json())\r\n    .map(res => plainToClass(User, res as Object[]))\r\n    .subscribe(users => {\r\n        // now \"users\" is type of User[] and each user has getName() and isAdult() methods available\r\n        console.log(users);\r\n    });\r\n```\r\n\r\nYou can also inject a class `ClassTransformer` as a service in `providers`, and use its methods.\r\n\r\nExample how to use with angular 2 in [plunker](http://plnkr.co/edit/Mja1ZYAjVySWASMHVB9R).\r\nSource code is [here](https://github.com/pleerock/class-transformer-demo).\r\n\r\n## Samples\r\n\r\nTake a look on samples in [./sample](https://github.com/pleerock/class-transformer/tree/master/sample) for more examples of\r\nusages.\r\n\r\n## Release notes\r\n\r\nSee information about breaking changes and release notes [here](https://github.com/pleerock/class-transformer/tree/master/doc/release-notes.md).\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pleerock/class-transformer.git"
  },
  "scripts": {
    "package": "gulp package",
    "test": "gulp tests"
  },
  "tags": [
    "deserialization",
    "object-to-class",
    "serialization",
    "serializer",
    "typescript",
    "typescript-serializer"
  ],
  "version": "0.2.3"
}
