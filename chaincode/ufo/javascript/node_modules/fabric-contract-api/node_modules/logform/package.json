{
  "_args": [
    [
      "logform@https://registry.npmjs.org/logform/-/logform-2.2.0.tgz",
      "/home/yumin/UFO_FabricNet_raft/chaincode/ufo/javascript/node_modules/fabric-contract-api"
    ]
  ],
  "_from": "logform@https://registry.npmjs.org/logform/-/logform-2.2.0.tgz",
  "_id": "logform@2.2.0",
  "_inCache": true,
  "_location": "/fabric-contract-api/logform",
  "_phantomChildren": {},
  "_requested": {
    "name": "logform",
    "raw": "logform@https://registry.npmjs.org/logform/-/logform-2.2.0.tgz",
    "rawSpec": "https://registry.npmjs.org/logform/-/logform-2.2.0.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/logform/-/logform-2.2.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/fabric-contract-api/winston"
  ],
  "_resolved": "https://registry.npmjs.org/logform/-/logform-2.2.0.tgz",
  "_shasum": "40f036d19161fc76b68ab50fdc7fe495544492f2",
  "_shrinkwrap": null,
  "_spec": "logform@https://registry.npmjs.org/logform/-/logform-2.2.0.tgz",
  "_where": "/home/yumin/UFO_FabricNet_raft/chaincode/ufo/javascript/node_modules/fabric-contract-api",
  "author": {
    "email": "charlie.robbins@gmail.com",
    "name": "Charlie Robbins"
  },
  "browser": "dist/browser.js",
  "bugs": {
    "url": "https://github.com/winstonjs/logform/issues"
  },
  "dependencies": {
    "colors": "^1.2.1",
    "fast-safe-stringify": "^2.0.4",
    "fecha": "^4.2.0",
    "ms": "^2.1.1",
    "triple-beam": "^1.3.0"
  },
  "description": "An mutable object-based log format designed for chaining & objectMode streams.",
  "devDependencies": {
    "@babel/cli": "^7.10.3",
    "@babel/core": "^7.10.3",
    "@babel/preset-env": "^7.10.3",
    "assume": "^2.2.0",
    "eslint-config-populist": "^4.1.0",
    "mocha": "^8.0.1",
    "nyc": "^15.1.0",
    "rimraf": "^3.0.2"
  },
  "homepage": "https://github.com/winstonjs/logform#readme",
  "keywords": [
    "format",
    "logging",
    "winston",
    "winstonjs"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "logform",
  "optionalDependencies": {},
  "readme": "# logform\n\nA mutable object-based log format designed for chaining & objectMode streams.\n\n``` js\nconst { format } = require('logform');\n\nconst alignedWithColorsAndTime = format.combine(\n  format.colorize(),\n  format.timestamp(),\n  format.align(),\n  format.printf(info => `${info.timestamp} ${info.level}: ${info.message}`)\n);\n```\n\n- [`info` Objects](#info-objects)\n- [Understanding formats](#understanding-formats)\n  - [Combining formats](#combining-formats)\n  - [Filtering `info` objects](#filtering-info-objects)\n- [Formats](#formats)\n  - [Align](#align)\n  - [CLI](#cli)\n  - [Colorize](#colorize)\n  - [Combine](#combine)\n  - [Errors](#errors)\n  - [JSON](#json)\n  - [Label](#label)\n  - [Logstash](#logstash)\n  - [Metadata](#metadata)\n  - [PadLevels](#padlevels)\n  - [PrettyPrint](#prettyprint)\n  - [Printf](#printf)\n  - [Simple](#simple)\n  - [Splat](#splat)\n  - [Timestamp](#timestamp)\n  - [Uncolorize](#uncolorize)\n\n## `info` Objects\n\nThe `info` parameter provided to a given format represents a single log\nmessage. The object itself is mutable. Every `info` must have at least the\n`level` and `message` properties:\n\n``` js\nconst info = {\n  level: 'info',                 // Level of the logging message  \n  message: 'Hey! Log something?' // Descriptive message being logged.\n}\n```\n\nProperties **besides level and message** are considered as \"`meta`\". i.e.:\n\n``` js\nconst { level, message, ...meta } = info;\n```\n\nSeveral of the formats in `logform` itself add additional properties:\n\n| Property    | Format added by | Description |\n| ----------- | --------------- | ----------- | \n| `splat`     | `splat()`       | String interpolation splat for `%d %s`-style messages. |\n| `timestamp` | `timestamp()`   |  timestamp the message was received. |\n| `label`     | `label()`       | Custom label associated with each message. | \n| `ms`        | `ms()`          | Number of milliseconds since the previous log message. |\n\nAs a consumer you may add whatever properties you wish – _internal state is\nmaintained by `Symbol` properties:_\n\n- `Symbol.for('level')` _**(READ-ONLY)**:_ equal to `level` property.\n  **Is treated as immutable by all code.**\n- `Symbol.for('message'):` complete string message set by \"finalizing formats\":\n  - `json`\n  - `logstash`\n  - `printf`\n  - `prettyPrint`\n  - `simple`\n- `Symbol.for('splat')`: additional string interpolation arguments. _Used\n  exclusively by `splat()` format._\n\nThese Symbols are stored in another package: `triple-beam` so that all\nconsumers of `logform` can have the same Symbol reference. i.e.:\n\n``` js\nconst { LEVEL, MESSAGE, SPLAT } = require('triple-beam');\n\nconsole.log(LEVEL === Symbol.for('level'));\n// true\n\nconsole.log(MESSAGE === Symbol.for('message'));\n// true\n\nconsole.log(SPLAT === Symbol.for('splat'));\n// true\n```\n\n## Understanding formats\n\nFormats are prototypal objects (i.e. class instances) that define a single method: `transform(info, opts)` and return the mutated `info`\n\n- `info`: an object representing the log message.\n- `opts`: setting specific to the current instance of the format.\n\nThey are expected to return one of two things:\n\n- **An `info` Object** representing the modified `info` argument. Object references need not be preserved if immutability is preferred. All current built-in formats consider `info` mutable, but [immutablejs] is being considered for future releases.\n- **A falsey value** indicating that the `info` argument should be ignored by the caller. (See: [Filtering `info` Objects](#filtering-info-objects)) below.\n\n`logform.format`  is designed to be as simple as possible. To define a new format simple pass it a `transform(info, opts)` function to get a new `Format`. \n\nThe named `Format` returned can be used to create as many copies of the given `Format` as desired:\n\n``` js\nconst { format } = require('logform');\n\nconst volume = format((info, opts) => {\n  if (opts.yell) {\n    info.message = info.message.toUpperCase(); \n  } else if (opts.whisper) {\n    info.message = info.message.toLowerCase();\n  }\n\n  return info;\n});\n\n// `volume` is now a function that returns instances of the format.\nconst scream = volume({ yell: true });\nconsole.dir(scream.transform({\n  level: 'info',\n  message: `sorry for making you YELL in your head!`\n}, scream.options));\n// {\n//   level: 'info'\n//   message: 'SORRY FOR MAKING YOU YELL IN YOUR HEAD!'\n// }\n\n// `volume` can be used multiple times to create different formats.\nconst whisper = volume({ whisper: true });\nconsole.dir(whisper.transform({ \n  level: 'info', \n  message: `WHY ARE THEY MAKING US YELL SO MUCH!` \n}), whisper.options);\n// {\n//   level: 'info'\n//   message: 'why are they making us yell so much!'\n// }\n```\n\n### Combining formats\n\nAny number of formats may be combined into a single format using `format.combine`. Since `format.combine` takes no `opts`, as a convenience it returns pre-created instance of the combined format.\n\n``` js\nconst { format } = require('logform');\nconst { combine, timestamp, label } = format;\n\nconst labelTimestamp = combine(\n  label({ label: 'right meow!' }),\n  timestamp()\n);\n\nconst info = labelTimestamp.transform({\n  level: 'info',\n  message: 'What time is the testing at?'\n});\n\nconsole.dir(info);\n// { level: 'info',\n//   message: 'What time is the testing at?',\n//   label: 'right meow!',\n//   timestamp: '2017-09-30T03:57:26.875Z' }\n```\n\n### Filtering `info` Objects\n\nIf you wish to filter out a given `info` Object completely then simply return a falsey value.\n\n``` js\nconst ignorePrivate = format((info, opts) => {\n  if (info.private) { return false; }\n  return info;\n});\n\nconsole.dir(ignorePrivate.transform({\n  level: 'error',\n  message: 'Public error to share'\n}));\n// { level: 'error', message: 'Public error to share' }\n\nconsole.dir(ignorePrivate.transform({\n  level: 'error',\n  private: true,\n  message: 'This is super secret - hide it.'\n}));\n// false\n```\n\nUse of `format.combine` will respect any falsey values return and stop evaluation of later formats in the series. For example:\n\n``` js\nconst { format } = require('logform');\nconst { combine, timestamp, label } = format;\n\nconst willNeverThrow = format.combine(\n  format(info => { return false })(), // Ignores everything\n  format(info => { throw new Error('Never reached') })()\n);\n\nconsole.dir(willNeverThrow.transform({\n  level: 'info',\n  message: 'wow such testing'\n}))\n```\n\n## Formats\n\n### Align\n\nThe `align` format adds a `\\t` delimiter before the message to align it in the same place.\n\n```js\nconst { format } = require('logform');\n\nconst alignFormat = format.align();\n\nconst info = alignFormat.transform({\n  level: 'info',\n  message: 'my message'\n});\n\nconsole.log(info);\n// { level: 'info', message: '\\tmy message' }\n```\n\nThis was previously exposed as `{ align: true }` in `winston < 3.0.0`.\n\n### CLI\n\nThe `cli` format is a combination of the `colorize` and the `padLevels` formats. It turns a log  `info` object into the same format previously available in `winston.cli()` in `winston < 3.0.0`.\n\n```js\nconst { format } = require('logform');\nconst LEVEL = Symbol.for('level');\n\nconst cliFormat = format.cli({ colors: { info: 'blue' }});\n\nconst info = cliFormat.transform({\n  [LEVEL]: 'info',\n  level: 'info',\n  message: 'my message'\n}, { all: true });\n\nconsole.log(info);\n// { level: '\\u001b[34minfo\\u001b[39m',\n//   message: '\\u001b[34m    my message\\u001b[39m',\n//   [Symbol(level)]: 'info',\n//   [Symbol(message)]:\n//    '\\u001b[34minfo\\u001b[39m:\\u001b[34m    my message\\u001b[39m' }\n```\n\n### Colorize\n\nThe `colorize` format adds different colors depending on the log level to the message and/or level.\nIt accepts the following options:\n\n* **level**: If set to `true` the color will be applied to the `level`.\n* **all**: If set to `true` the color will be applied to the `message` and `level`.\n* **message**: If set to `true` the color will be applied to the `message`.\n* **colors**: An object containing the colors for the log levels. For example: `{ info: 'blue', error: 'red' }`\n\n```js\nconst { format } = require('logform');\nconst LEVEL = Symbol.for('level');\n\nconst colorizeFormat = format.colorize({ colors: { info: 'blue' }});\n\nconst info = colorizeFormat.transform({\n  [LEVEL]: 'info',\n  level: 'info',\n  message: 'my message'\n}, { all: true });\n\nconsole.log(info);\n// { level: '\\u001b[34minfo\\u001b[39m',\n//   message: '\\u001b[34mmy message\\u001b[39m',\n//   [Symbol(level)]: 'info' }\n```\n\nThis was previously exposed as `{ colorize: true }` to transports in `winston < 3.0.0`.\n\n### Combine\n\nThe `combine` Format allows to combine multiple formats:\n\n```js\nconst { format } = require('logform');\nconst { combine, timestamp, json } = format;\n\nconst jsonWithTimestamp = combine(\n  timestamp(),\n  json()\n);\n\nconst info = jsonWithTimestamp.transform({\n  level: 'info',\n  message: 'my message'\n});\n\nconsole.log(info);\n// { level: 'info',\n//   message: 'my message',\n//   timestamp: '2018-10-02T15:03:14.230Z',\n//   [Symbol(message)]:\n//    '{\"level\":\"info\",\"message\":\"my message\",\"timestamp\":\"2018-10-02T15:03:14.230Z\"}' }\n```\n\n### Errors\n\nThe `errors` format allows you to pass in an instance of a JavaScript `Error`\ndirectly to the logger. It allows you to specify whether not to include the\nstack-trace.\n\n```js\nconst { format } = require('logform');\nconst { errors } = format;\n\nconst errorsFormat = errors({ stack: true })\n\nconst info = errorsFormat.transform(new Error('Oh no!'));\n\nconsole.log(info);\n// Error: Oh no!\n//     at repl:1:13\n//     at ContextifyScript.Script.runInThisContext (vm.js:50:33)\n//     at REPLServer.defaultEval (repl.js:240:29)\n//     at bound (domain.js:301:14)\n//     at REPLServer.runBound [as eval] (domain.js:314:12)\n//     at REPLServer.onLine (repl.js:468:10)\n//     at emitOne (events.js:121:20)\n//     at REPLServer.emit (events.js:211:7)\n//     at REPLServer.Interface._onLine (readline.js:282:10)\n//     at REPLServer.Interface._line (readline.js:631:8)\n```\n\nIt will also handle `{ message }` properties as `Error` instances:\n\n```js\nconst { format } = require('logform');\nconst { errors } = format;\n\nconst errorsFormat = errors({ stack: true })\n\nconst info = errorsFormat.transform({\n  message: new Error('Oh no!')\n});\n\nconsole.log(info);\n// Error: Oh no!\n//     at repl:1:13\n//     at ContextifyScript.Script.runInThisContext (vm.js:50:33)\n//     at REPLServer.defaultEval (repl.js:240:29)\n//     at bound (domain.js:301:14)\n//     at REPLServer.runBound [as eval] (domain.js:314:12)\n//     at REPLServer.onLine (repl.js:468:10)\n//     at emitOne (events.js:121:20)\n//     at REPLServer.emit (events.js:211:7)\n//     at REPLServer.Interface._onLine (readline.js:282:10)\n//     at REPLServer.Interface._line (readline.js:631:8)\n```\n\n### JSON\n\nThe `json` format uses `fast-safe-stringify` to finalize the message.\nIt accepts the following options:\n\n* **replacer**: A function that influences how the `info` is stringified.\n* **space**: The number of white space used to format the json.\n* **stable**: If set to `true` the objects' attributes will always be stringified in alphabetical order.\n\n```js\nconst { format } = require('logform');\n\nconst jsonFormat = format.json();\n\nconst info = jsonFormat.transform({\n  level: 'info',\n  message: 'my message',\n  stable: true,\n});\nconsole.log(info);\n// { level: 'info',\n//   message: 'my message',\n//   [Symbol(message)]: '{\"level\":\"info\",\"message\":\"my message\"}' }\n```\n\nThis was previously exposed as `{ json: true }` to transports in `winston < 3.0.0`.\n\n### Label\n\nThe `label` format adds the specified `label` before the message or adds it to the `info` object.\nIt accepts the following options:\n\n* **label**: A label to be added before the message.\n* **message**: If set to `true` the `label` will be added to `info.message`. If set to `false` the `label` will be added as `info.label`.\n\n```js\nconst { format } = require('logform');\n\nconst labelFormat = format.label();\n\nconst info = labelFormat.transform({\n  level: 'info',\n  message: 'my message'\n}, { label: 'my label', message: true });\n\nconsole.log(info);\n// { level: 'info', message: '[my label] my message' }\n```\n\nThis was previously exposed as `{ label: 'my label' }` to transports in `winston < 3.0.0`.\n\n### Logstash\n\nThe `logstash` Format turns a log `info` object into pure JSON with the appropriate logstash options.\n\n```js\nconst { format } = require('logform');\nconst { logstash, combine, timestamp } = format;\n\nconst logstashFormat = combine(\n  timestamp(),\n  logstash()\n);\n\nconst info = logstashFormat.transform({\n  level: 'info',\n  message: 'my message'\n});\n\nconsole.log(info);\n// { level: 'info',\n//   [Symbol(message)]:\n//    '{\"@message\":\"my message\",\"@timestamp\":\"2018-10-02T11:04:52.915Z\",\"@fields\":{\"level\":\"info\"}}' }\n```\n\nThis was previously exposed as `{ logstash: true }` to transports in `winston < 3.0.0`.\n\n### Metadata\n\nThe `metadata` format adds a metadata object to collect extraneous data, similar to the metadata object in winston 2.x.\nIt accepts the following options:\n\n* **key**: The name of the key used for the metadata object. Defaults to `metadata`.\n* **fillExcept**: An array of keys that should not be added to the metadata object.\n* **fillWith**: An array of keys that will be added to the metadata object.\n\n```js\nconst { format } = require('logform');\n\nconst metadataFormat = format.metadata();\n\nconst info = metadataFormat.transform({\n  level: 'info',\n  message: 'my message',\n  meta: 42\n});\n\nconsole.log(info);\n// { level: 'info', message: 'my message', metadata: { meta: 42 } }\n```\n\n### PadLevels\n\nThe `padLevels` format pads levels to be the same length.\n\n```js\nconst { format } = require('logform');\nconst LEVEL = Symbol.for('level');\n\nconst padLevelsFormat = format.padLevels();\n\nconst info = padLevelsFormat.transform({\n  [LEVEL]: 'info',\n  message: 'my message'\n});\n\nconsole.log(info);\n// { message: '    my message', [Symbol(level)]: 'info' }\n```\n\nThis was previously exposed as `{ padLevels: true }` to transports in `winston < 3.0.0`.\n\n### PrettyPrint\n\nThe `prettyPrint` format finalizes the message using `util.inspect`.\nIt accepts the following options:\n\n* **depth**: A `number` that specifies the maximum depth of the `info` object being stringified by `util.inspect`. Defaults to `2`.  \n* **colorize**: Colorizes the message if set to `true`. Defaults to `false`.\n\nThe `prettyPrint` format should not be used in production because it may impact performance negatively and block the event loop.\n\n> **NOTE:** the `LEVEL`, `MESSAGE`, and `SPLAT` symbols are stripped from the\n> output message _by design._\n\nThis was previously exposed as `{ prettyPrint: true }` to transports in `winston < 3.0.0`.\n\n```js\nconst { format } = require('logform');\n\nconst prettyPrintFormat = format.prettyPrint();\n\nconst info = prettyPrintFormat.transform({\n  [LEVEL]: 'info',\n  level: 'info',\n  message: 'my message'\n});\n\nconsole.log(info);\n// { level: 'info',\n//   message: 'my message',\n//   [Symbol(level)]: 'info',\n//   [Symbol(message)]: '{ level: \\'info\\', message: \\'my message\\' }' }\n```\n\n### Printf\n\nThe `printf` format allows to create a custom logging format:\n\n```js\nconst { format } = require('logform');\n\nconst myFormat = format.printf((info) => {\n  return `${info.level} ${info.message}`;\n})\n\nconst info = myFormat.transform({\n  level: 'info',\n  message: 'my message'\n});\n\nconsole.log(info);\n// { level: 'info',\n//   message: 'my message',\n//   [Symbol(message)]: 'info my message' }\n```\n\n### Simple\n\nThe `simple` format finalizes the `info` object using the format: `level: message stringifiedRest`.\n```js\nconst { format } = require('logform');\nconst MESSAGE = Symbol.for('message');\n\nconst simpleFormat = format.simple();\n\nconst info = simpleFormat.transform({\n  level: 'info',\n  message: 'my message',\n  number: 123\n});\nconsole.log(info[MESSAGE]);\n// info: my message {number:123}\n```\n\n### Splat\n\nThe `splat` format transforms the message by using `util.format` to complete any `info.message` provided it has string interpolation tokens.\n\n```js\nconst { format } = require('logform');\n\nconst splatFormat = format.splat();\n\nconst info = splatFormat.transform({\n  level: 'info',\n  message: 'my message %s',\n  splat: ['test']\n});\n\nconsole.log(info);\n// { level: 'info', message: 'my message test', splat: [ 'test' ] }\n```\n\nAny additional splat parameters beyond those needed for the `%` tokens\n(aka \"metas\") are assumed to be objects. Their enumerable properties are\nmerged into the `info`.\n\n```js\nconst { format } = require('logform');\n\nconst splatFormat = format.splat();\n\nconst info = splatFormat.transform({\n  level: 'info',\n  message: 'my message %s',\n  splat: ['test', { thisIsMeta: true }]\n});\n\nconsole.log(info);\n// { level: 'info',\n//   message: 'my message test',\n//   thisIsMeta: true,\n//   splat: [ 'test' ] }\n```\n\nThis was previously exposed implicitly in `winston < 3.0.0`.\n\n### Timestamp\n\nThe `timestamp` format adds a timestamp to the info. \nIt accepts the following options:\n\n* **format**: Either the format as a string accepted by the [fecha](https://github.com/taylorhakes/fecha) module or a function that returns a formatted date. If no format is provided `new Date().toISOString()` will be used.\n* **alias**: The name of an alias for the timestamp property, that will be added to the `info` object. \n\n```js\nconst { format } = require('logform');\n\nconst timestampFormat = format.timestamp();\n\nconst info = timestampFormat.transform({\n  level: 'info',\n  message: 'my message'\n});\n\nconsole.log(info);\n// { level: 'info',\n//   message: 'my message',\n//   timestamp: '2018-10-02T11:47:02.682Z' }\n```\n\nIt was previously available in `winston < 3.0.0` as `{ timestamp: true }` and `{ timestamp: function:String }`.\n\n\n### Uncolorize\n\nThe `uncolorize` format strips colors from `info` objects.\nIt accepts the following options:\n\n* **level**: Disables the uncolorize format for `info.level` if set to `false`. \n* **message**: Disables the uncolorize format for `info.message` if set to `false`. \n* **raw**: Disables the uncolorize format for `info[MESSAGE]` if set to `false`. \n\nThis was previously exposed as `{ stripColors: true }` to transports in `winston < 3.0.0`.\n\n## Tests\n\nTests are written with `mocha`, `assume`, and `nyc`. They can be run with `npm`:\n\n```\nnpm test\n```\n\n##### LICENSE: MIT\n##### AUTHOR: [Charlie Robbins](https://github.com/indexzero)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/winstonjs/logform.git"
  },
  "scripts": {
    "build": "rimraf dist && babel *.js -d ./dist",
    "lint": "populist *.js test/*.js examples/*.js",
    "prepublishOnly": "npm run build",
    "pretest": "npm run lint && npm run build",
    "test": "nyc mocha test/*.test.js"
  },
  "types": "./index.d.ts",
  "version": "2.2.0"
}
